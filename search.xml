<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 70.爬楼梯</title>
      <link href="/2020/02/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2020/02/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p></blockquote><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h1><blockquote><p>示例1：<br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1: 1 阶 + 1 阶<br>2: 2 阶</p></blockquote><blockquote><p>示例 2：<br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1: 1 阶 + 1 阶 + 1 阶<br>2: 1 阶 + 2 阶<br>3: 2 阶 + 1 阶</p></blockquote><h1 id="3-解法"><a href="#3-解法" class="headerlink" title="3 解法"></a>3 解法</h1><h2 id="3-1-暴力破解"><a href="#3-1-暴力破解" class="headerlink" title="3.1 暴力破解"></a>3.1 暴力破解</h2><ul><li><p>采用递归的方法：将会把所有可能爬的阶数进行组合，也就是$1$和$2$。而在每一步中我们都会继续调用$climbStairs$这个函数模拟爬$1$阶和$2$阶的情形，并返回两个函数的返回值之和。<br>$$<br>climbStairs(i, n)=(i+1, n)+climbStairs(i+2, n)<br>$$<br>其中$i$定义了当前阶数，而$n$定义了目标阶数。</p></li><li><p>在$n=5$时，递归树是这样的：<br><img src="LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF.assets/20191122202605534.png" alt="在这里插入图片描述"></p></li><li><p>Python3实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> climbStairs(<span class="number">0</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(i, n)</span>:</span></span><br><span class="line"><span class="keyword">if</span> i &gt; n:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> i == n:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> climbStairs(i+<span class="number">1</span>, n) + climbStairs(i+<span class="number">2</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="keyword">print</span> (solution(n))</span><br></pre></td></tr></table></figure><h2 id="3-2-记忆化递归"><a href="#3-2-记忆化递归" class="headerlink" title="3.2 记忆化递归"></a>3.2 记忆化递归</h2></li><li><p>在上一种方法中，我们计算每一步的结果时出现了冗余，观察上图的递归树可以看出，$(4,5)$在树中出现了许多次，而用$memo[4]$可以直接记忆$i=4$时的方法数。因此我们可以把每一步的结果存储在$memo$数组之中，每当函数再次被调用，我们就直接从$memo$数组返回结果。</p></li><li><p>在$memo$数组的帮助下，我们得到了一个修复的递归树，其大小减少到$n$。</p></li><li><p>Python3实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span></span><br><span class="line">memo = [<span class="number">0</span>]*n</span><br><span class="line"><span class="keyword">return</span> climbStairs(<span class="number">0</span>, n, memo)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(i, n, memo)</span>:</span></span><br><span class="line"><span class="keyword">if</span> i &gt; n:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> i == n:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> memo[i] &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> memo[i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">memo[i] = climbStairs(i+<span class="number">1</span>, n, memo) + climbStairs(i+<span class="number">2</span>, n, memo)</span><br><span class="line"><span class="keyword">return</span> memo[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="keyword">print</span> (solution(n))</span><br></pre></td></tr></table></figure><h2 id="3-3-动态规划法"><a href="#3-3-动态规划法" class="headerlink" title="3.3 动态规划法"></a>3.3 动态规划法</h2></li><li><p>不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。</p></li><li><p>第$i$阶可以由以下两种方法得到：</p><ul><li>在第$(i-1)$阶后向上爬$1$阶。</li><li>在第$(i-2)$阶后向上爬$2$阶。</li></ul></li><li><p>所以到达第$i$阶的方法总数就是到第$(i−1)$阶和第$(i−2)$阶的方法数之和。</p></li><li><p>令$dp[i]$表示能到达第$i$阶的方法总数：<br>$$<br>dp[i]=dp[i-1]+dp[i-2]<br>$$</p></li><li><p>Python3实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">pre = <span class="number">2</span></span><br><span class="line">ppre = <span class="number">1</span></span><br><span class="line">times = n<span class="number">-2</span></span><br><span class="line"><span class="keyword">while</span> times:</span><br><span class="line">times -= <span class="number">1</span></span><br><span class="line">ans = pre + ppre</span><br><span class="line">ppre = prepre = ans</span><br><span class="line"><span class="keyword">print</span> (ans)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-斐波那契数列"><a href="#3-4-斐波那契数列" class="headerlink" title="3.4 斐波那契数列"></a>3.4 斐波那契数列</h2><ul><li>观察答案序列可知，是一个斐波那契数列，直接套用公式即可，这里不再赘述。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69.x的平方根-牛顿迭代法</title>
      <link href="/2020/02/05/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
      <url>/2020/02/05/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h1><blockquote><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p></blockquote><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h1><blockquote><p>示例 1:<br>输入: 4<br>输出: 2</p></blockquote><blockquote><p>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p></blockquote><h1 id="3-牛顿迭代法"><a href="#3-牛顿迭代法" class="headerlink" title="3 牛顿迭代法"></a>3 牛顿迭代法</h1><ul><li>求x的平方根：首先随便猜一个近似值$cur$，然后不断令$cur$等于 <kbd>$cur$ 和 $x/cur$ 的平均数</kbd>，迭代个六七次后$cur$的值就已经相当精确了。</li></ul><p>例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：</p><blockquote><p>( 4 + 2/ 4 ) / 2 = 2.25<br>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br>….</p></blockquote><p>4<img src="https://img-blog.csdnimg.cn/20191120225747380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>算法原理：</strong></p><ul><li>我们不断用$(x, f(x))$的切线来逼近方程$x^{2}-a=0$的根。根号$a$实际上就是$x^{2}-a=0$的一个正实根，这个函数的导数是$2x$。也就是说，函数上任一点$(x, f(x))$处的切线斜率是$2x$。</li><li>那么，过点$(x, f(x))$的切线与x轴的交点横坐标为$((x^{2}+a)/2x,0)$，其中$x^{2}+a/2x$就是一个比 $x$更接近的近似值。化简后也就是$(x+a / x) / 2$。</li><li>下面的图片可以更形象的理解这种逼近过程：<br><img src="https://img-blog.csdnimg.cn/20191120231827785.gif#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="4-LeetCode代码实现"><a href="#4-LeetCode代码实现" class="headerlink" title="4 LeetCode代码实现"></a>4 LeetCode代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = x</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = (cur + x/cur) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> abs(pre-cur) &lt; <span class="number">1e-6</span>:</span><br><span class="line">                    <span class="keyword">return</span> int(cur)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 14.最长公共前缀</title>
      <link href="/2020/02/05/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2020/02/05/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><blockquote><p>编写一个函数来查找字符串数组中的<strong>最长公共前缀</strong>。<br>如果不存在公共前缀，返回空字符串 “”</p></blockquote><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h1><blockquote><p>输入：[“flower”,”flow”,”flight”]<br>输出：”fl”</p></blockquote><h1 id="3-解法"><a href="#3-解法" class="headerlink" title="3 解法"></a>3 解法</h1><h2 id="3-1-解法一：水平扫描法"><a href="#3-1-解法一：水平扫描法" class="headerlink" title="3.1 解法一：水平扫描法"></a>3.1 解法一：水平扫描法</h2><p><strong>算法描述：</strong><br>首先，将列表中的字符串按照长度重新排序，然后依次遍历字符串$\left[S_{1} \ldots S_{n}\right]$，首先求$L C P\left(S_{1}, S_{2}\right)$，然后求$L C P\left(L C P\left(S_{1}, S_{2}\right), S_{3}\right)$，依次类推：</p><p>$L C P\left(S_{1} \ldots S_{n}\right)=L C P\left(L C P\left(L C P\left(S_{1}, S_{2}\right), S_{3}\right), \ldots S_{n}\right)$</p><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190826163223697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190826163223697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center</a> =380x400)</p><center>图 1. 查找最长公共前缀 （水平扫描法）</center><kbd>**Python3实现**</kbd><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(strs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">strs = sorted(strs, key=len)</span><br><span class="line">prefix = strs[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(strs)):</span><br><span class="line"><span class="keyword">while</span> strs[i].find(prefix) != <span class="number">0</span>:</span><br><span class="line">prefix = prefix[<span class="number">0</span>:len(prefix)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> len(prefix) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>## 3.2 解法二：分治法<p><strong>算法描述</strong><br>这个算法的思路来自于LCP操作的结合律。 我们可以发现：</p><p>$L C P\left(S_{1} \ldots S_{n}\right)=L C P\left(L C P\left(S_{1} \ldots S_{k}\right), L C P\left(S_{k+1} \ldots S_{n}\right)\right)$</p><p>，其中$\operatorname{LCP}\left(S_{1} \ldots S_{n}\right)$是字符串$\left[S_{1} \ldots S_{n}\right]$的最长公共前缀，$1&lt;k&lt;n$。<br>为了应用上述的结论，我们使用分治的技巧，将原问题$L C P\left(S_{i} \cdots S_{j}\right)$分成两个子问题$L C P\left(S_{i} \cdots S_{m i d}\right)$与$L C P\left(S_{m i d+1}, S_{j}\right)$。</p><p>其中<kbd>mid =$\frac{i+j}{2}$</kbd>。 我们用子问题的解 <kbd>lcpLeft</kbd> 与<kbd> lcpRight</kbd> 构造原问题的解。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解。<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190826164803801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190826164803801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center</a> =400x350)</p><center>图 2. 查找最长公共前缀的分治方法</center><kbd>**Python3实现**</kbd><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(strs)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(strs, l, r)</span>:</span></span><br><span class="line"><span class="keyword">if</span> l == r:</span><br><span class="line"><span class="keyword">return</span> strs[l]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mid = (l+r)//<span class="number">2</span></span><br><span class="line">lcpLeft = recursion(strs, l, mid)</span><br><span class="line">lcpRight = recursion(strs, mid+<span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">return</span> commonPrefix(lcpLeft,lcpRight)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commonPrefix</span><span class="params">(left, right)</span>:</span></span><br><span class="line"><span class="keyword">while</span> right.find(left) != <span class="number">0</span>:</span><br><span class="line">left = left[<span class="number">0</span>:len(left)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> len(left) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> recursion(strs, <span class="number">0</span>, len(strs)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>## 3.3 解法三：二分查找法<p><strong>算法描述</strong><br>应用<strong>二分查找法</strong>找到所有字符串的公共前缀的最大长度<kbd> L</kbd>。 算法的查找区间是$(0 \ldots \min L e n)$，其中 <kbd>minLen</kbd> 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，算法进行的过程中一共会出现两种可能情况：</p><ul><li><p>S[1…mid] 不是所有串的公共前缀。 这表明该前缀加上mid后面的字符也一定不是公共前缀，于是我们就可以丢弃后半个查找区间。</p></li><li><p>S[1…mid] 是所有串的公共前缀。 这表示该前缀加上mid后面的字符有可能也是公共前缀，因为我们要找最长的公共前缀，所以我们将mid后的字符附加在S[1…mid]后继续进行匹配。<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2019082616574493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/2019082616574493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjMGZpZTFk,size_16,color_FFFFFF,t_70#pic_center</a> =400x500)</p><center>图 3. 使用二分查找法寻找最长公共前缀</center><kbd>**Python3实现**</kbd><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(strs)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCommonPrefix</span><span class="params">(strs, length)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(strs)):</span><br><span class="line"><span class="keyword">if</span> strs[i].find(strs[<span class="number">0</span>][<span class="number">0</span>:length+<span class="number">1</span>]) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">strs = sorted(strs, key=len)</span><br><span class="line">low, high = <span class="number">0</span>, len(strs[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> low &lt;= high:</span><br><span class="line">mid = (low + high) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> isCommonPrefix(strs, mid):</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> ((low + high) // <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>][<span class="number">0</span>:(low + high) // <span class="number">2</span> + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 53.最大子序和-动态规划法</title>
      <link href="/2020/02/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95/"/>
      <url>/2020/02/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h1><blockquote><p><strong>输入</strong>：[-2,1,-3,4,-1,2,1,-5,4]<br><strong>输出</strong>：6<br><strong>解释</strong>：连续子数组 [4,-1,2,1] 的和最大，为 6</p></blockquote><h1 id="3-题解"><a href="#3-题解" class="headerlink" title="3 题解"></a>3 题解</h1><p> <strong>我们用<kbd>动态规划</kbd>的思路来解决该问题：</strong></p><p>对数组进行遍历，用<kbd>sum</kbd>记录遍历到当前元素时，前面若干个连续子序列的最大和；用<kbd>ans</kbd>来存储最终的结果。sum和ans的初值都为数组的第一个元素        </p><ul><li>若<kbd>sum > 0</kbd>，则sum产生增益效果，保留sum并加上当前遍历元素</li><li>若<kbd>sum <= 0</kbd>，则sum无增益效果，则舍弃sum并令sum等于当前元素，重新计算收益</li><li>每次遍历，都将sum和ans进行比较，若<kbd>sum > ans</kbd>，则将ans的值更新为sum</li></ul><p><strong>这里有一种比较形象的方式来理解动态规划：</strong></p><p>假设你是一个选择性遗忘的赌徒，数组表示你这几天来赢钱或者输钱。<br>你用sum来表示之前几天来的输赢，用ans来存储你手里赢到的最多的钱.</p><ul><li>如果昨天你手上还是输钱（sum &lt; 0），你忘记它，从今天重新开始算起；</li><li>如果昨天你手上还是赢钱（sum &gt; 0），你记得它，加上今天的战绩；</li><li>及时更新ans，存储sum的最大值。</li></ul><h1 id="4-Python3代码实现"><a href="#4-Python3代码实现" class="headerlink" title="4 Python3代码实现"></a>4 Python3代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">sum = nums[<span class="number">0</span>]</span><br><span class="line">ans = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line"><span class="keyword">if</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">sum += nums[i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">sum = nums[i]</span><br><span class="line"><span class="keyword">if</span> sum &gt; ans:</span><br><span class="line">ans = sum  </span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习与安全》读书笔记</title>
      <link href="/2020/02/03/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/03/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>我看的是《Machine Learning and Security》的翻译版，原书应该是安全数据科学领域一本比较不错的而且较为基础的书，奈何翻译的太差而且本人水平有限，对书中的许多内容了解的不多，而且书中的代码部分并没有自己亲自实现，只是选取了安全领域的异常检测、恶意软件分析和网络流量分析三个部分做了笔记。希望在学习一段时间之后，能够对之前不了解的内容有所掌握，并且实现一下书中的实战部分。另外如果再读此书的话，一定要读英文版。</p><h1 id="1-异常检测"><a href="#1-异常检测" class="headerlink" title="1 异常检测"></a>1 异常检测</h1><p>（1）AI for security分为两类：模式识别和异常检测</p><ul><li>模式识别：发现数据中的特性，将其提炼成特征集</li><li>异常检测：建立一个描述正常状态的特征，所有偏离该状态的情况都被视为异常 </li></ul><p>（2）shell命令可以形成一个时间序列，因此可以从时间序列分析的角度进行异常检测</p><p>（3）主机入侵检测</p><ul><li>工具框架：osquery（收集低层级OS Metics，可以使用基于SQL的接口进行查询）、Linux auditd</li><li>可以利用第三方工具将上述两种工具集成到自动化业务流程框架中，如：Chef、Puppet、 Ansible、SaltStack、Kolide、doorman</li><li>Indicator Of Compromise</li></ul><p>（4）网络入侵检测</p><ul><li>流量分析工具：tcpdump、Bro、Snort</li><li>检测单位是流量</li><li>提取网络流量元数据<ul><li>基于状态数据包检测（stateful packet inspection，SPI）</li><li>工作在3、4层</li><li>检查数据包的头尾而不触及数据包上下文</li><li>保持先前收到的数据包的状态、从而能够将新接收到的数据包与先前的相关联</li></ul></li><li>检查网络流量内容<ul><li>深度包检测（Deep packet inspection、DPI）</li><li>工作在应用层</li><li>Bro（可以检测HTTP请求POST的字符串，从而可以检测SQL注入和XSS）</li><li>如果要在使用了TLS/SSL加密的环境中进行检测，只能在监测点取消加密</li></ul></li></ul><p>（5）Web应用程序入侵检测</p><ul><li>标准Web服务器以NCSA通用日志格式来生成日志</li></ul><p>（6）异常检测方法——预测（监督学习）</p><ul><li>适用于一维实值度量序列</li><li>思想：将预测与观测之间的偏差视为异常</li><li>ARIMA (autoregressive integrated moving average，自回归积分移动平均模型)，通过使用正常的数据集，由序列与以前时间点自身之间的相关性（autocorrelation，自相关），来预测接下来的时间段内的状态。在预测相对准确的情况下（预测结果与实际观测到的非异常状态拟合度较高），如果观测值与预测结果之间的差值超过了某个threshold，则认为发生了异常。</li><li>人工神经网络（Particularly，长短期记忆网络（long short-term memory，LSTM））</li><li>注意：预测适合novelty detection（训练集中不包含异常数据），而不适合outlier detection（离群点检测，训练集中包含异常数据）。即适合训练集中没有异常数据，如果训练集包含异常数据的话，容易造成在训练过程中对预测数据的过拟合，从而使观测到的异常状态与预测值之间的差值变小，异常检测效果下降。</li></ul><p>（7）统计度量</p><ul><li>绝对中位差（median absolute deviation，MAD）：去查找一群数据中的离群值，表示为数列中位数的绝对偏差的中位数<br>import numpy as np<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Input data series</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># Calculate median absolute deviation</span></span><br><span class="line">mad = np.median(np.abs(x - np.median(x)))</span><br><span class="line"><span class="comment"># MAD of x is 1.5</span></span><br></pre></td></tr></table></figure></li><li>Grubbs的离群值检测</li><li>Goodness-of-fit——椭圆包络拟合（Elliptic envelope itting (covariance estimate itting)）</li></ul><p>（8）异常检测方法——无监督学习</p><ul><li>单类支持向量机</li><li>孤立森林<ul><li>随机森林非常适合高维数据的异常检测，适合时间序列数据的实时异常检测</li><li>思想：异常数据和正常数据相比，可以用较少的次数将其与正常数据分隔开</li></ul></li><li>K均值</li></ul><p>（9）异常检测方法——基于密度的方法</p><ul><li>KNN</li><li>局部离群因子（Local outlier factor，LOF）</li></ul><p>（10）入侵检测面临的问题</p><ul><li>错误代价高</li><li>语义鸿沟</li><li>可解释性</li></ul><h1 id="2-恶意软件分析"><a href="#2-恶意软件分析" class="headerlink" title="2 恶意软件分析"></a>2 恶意软件分析</h1><p>（1）恶意软件类别划分依据：family</p><p>（2）可以用静态签名匹配来判断是否是恶意软件</p><p>（3）使用机器学习进行恶意软件分类的优势</p><ul><li>模糊匹配：给出了两个实体之间的相似程度，而不是简单的yes or no</li><li>自动特征加权和选择</li><li>适应性：适应不断变化的输入，跟踪恶意软件的进化</li></ul><p>（4）使用机器学习进行恶意软件分类的挑战：特征工程</p><p>（5）二进制可执行文件的特征生成：</p><ul><li>静态方法：<ul><li>结构分析：查看程序的文件构成</li><li>静态分析：查看程序的代码</li></ul></li><li>动态分析：运行程序分析（沙箱）<ul><li>调试</li><li>动态插桩：通过挂钩正在运行的进程，并将自定义逻辑注入到应用程序中，从而修改应用程序或环境的运行时行为<br>可用做特征的指标：</li></ul></li></ul><p>（6）程序请求权限</p><ul><li>系统调用</li><li>操作码n-gram（一个包含其它特征的序列）</li><li>网络行为</li><li>logcat</li></ul><p>（7）特征选择：</p><ul><li>单变量分析：迭代地对每个单独特征进行分析，在只考虑该特征的情况下，模型执行会有多好；从而可以得到对特征好坏的评估</li><li>递归特征消除：从完整的特征集开始，分析特征的排除对模型情况的影响</li><li>潜在特征值表示：奇异值分解（SVD）、主成分分析（PCA）</li><li>特定模型中通过特征权重减小或消除某些特征对模型的影响</li></ul><h1 id="3-网络流量分析"><a href="#3-网络流量分析" class="headerlink" title="3 网络流量分析"></a>3 网络流量分析</h1><p>（1）无监督特征学习：指的是从原始数据自动生成特征，不同于无监督学习</p><p>（2）TSL/SSL数据包可以被解密</p><p>（3）攻击分为被动攻击和主动攻击</p><ul><li>被动攻击：不会启动与网络中节点的通信，也不会与网络数据交互或修- 改网络数据；而是进行信息收集和侦察活动。</li><li>主动攻击<ul><li>漏洞：用过远程服务器发送的命令，可以使用基于机器学习模糊匹配来检测</li><li>欺骗：DNS欺骗、ARP欺骗</li><li>横向移动</li><li>拒绝服务</li></ul></li></ul><p>（4）C&amp;C服务器控制僵尸网络，C&amp;C服务器的体系结构如下：</p><ul><li>星形/集中式网络    </li><li>多重网络：解决了a中的单点故障、可以缓和物理距离带来的问题</li><li>分层网络：为了解决指令必须集中发布的问题</li><li>随机P2P网络：僵尸网络管理员可以向僵尸网络中的任何一个节点发布指令，然后指令在网络中以多点传送的方式进行传播</li></ul><p>（4）使用NSLKDD数据金构建网络攻击分类预测模型</p><ul><li>数据由TCPDump产生有标记的数据集，包含38种攻击类型，只有24种在训练集中出现，攻击属于下面四大类：<ul><li>dos：拒绝服务</li><li>r2l：来自远程服务器的未授权的访问</li><li>u2r：提权尝试</li><li>probe：探测性暴力破解攻击</li></ul></li><li>我们的任务是设计一个通用的分类器，将数据分为五类：4类攻击+良性</li><li>类不平衡问题：训练集中属于r2l和u2l的数据占比非常少，因此在测试集中对这两类数据的分类效果极差，由于训练集中benign数据占比最大，因此这两类数据大部分都被预测为benign数据。</li><li>处理类不平衡的方法：<ul><li>欠采样：在占比较大的数据中进行采样，选取一部分进行使用，而不是用全部的数据集</li><li>过采样：为占比较少的数据类智能合成数据点</li><li>流行的做法是先过采样，再欠采样</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安全数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
